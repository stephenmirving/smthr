@use 'sass:list';
@use 'sass:meta';
@use 'sass:map';
@use 'sass:math';
@use '../variables/maps' as *;

// TODO: Maybe take an equation that is not a calc() equation and not one that
// only has a time/progress variable and move it to a separate function

/// Takes a name for an equation and returns the respective equation. Unless
/// mentioned otherwise in the comments, will return a CSS calc() function, but
/// some keywrd equation names will return other CSS functions. Unless mentioned
/// otherwise in the comments, pass an argument representing the progress of the
/// animation, a value of 0-1 or 0% - 100%
///
/// @param {String} $equation-name - The name of the custom equation. The full
/// list of
/// @param {*} $args - The argument(s) required for the specific calculation.
/// Unless mentioned otherwise in the comments, pass an argument representing
/// the progress of the animation, a value of 0-1 or 0% - 100%. Some functions
/// may have other arguments to pass. These are listed in the comments in the
/// equation map in this function
///
/// @return {Calculation} The CSS function that matches the equation name.
///
/// @example scss
/// .element {
///
/// }
///
/// @access public
/// @group Utilities
/// @require {variable} $map-equations
///
/// @throw Invalid $equation-name data type error.
/// @throw Equation name not found in alias map error.
@function resolve-equation($equation-name, $args...) {
  // Most often the progress argument
  $arg1: list.nth($args, 1);
  $arg2: list.nth($args, 2);

  $map-equations: (
    // Emulating Sinusoidal motion
    'oscillation':
      calc(50% + 25% * (1 - math.cos($arg1 * math.$pi * 2))),
    // Emulating Sinusoidal motion, create and up/down motion effect
    'height-oscillation':
      calc(100px + 50px * (1 - math.cos($arg1 * math.$pi))),
    // Varies the height of an element, creating a vertical wave effect.
    'height-wave': calc(50% + math.sin($arg1) * 25 * 1%);
    // Emulate Sinusoidal horizontal movement
    'sin-x': calc(50% + (math.sin($arg1) * 100 * 1px)),
    // Emulate Cosine vertical movement
    'cos-y': calc(50% + (math.cos($arg1) * 100 * 1px)),
    // Dynamic scaling, use in a scale() function
    'dynamic-scale': calc(1 + 0.5 * math.cos($arg1)),
    // Similar to sinusoidal horizontal movement but with a different amplitude,
    // creating a wave effect along the x-axis.
    'wave-x': calc(50% + math.sin($arg1) * 50 * 1px),
    // Y-axis bounce
    'sin-bounce': calc(50% + math.sin($arg1) * 30 * 1px),
    // Circular motion on the X-axis, pass an argument representing the angle
    'circular-motion-x': calc(50% + 100px * math.cos($arg1)),
    // Circular motion on the Y-axis, pass an argument representing the angle
    'circular-motion-y': calc(50% + 100px * math.sin($arg1)),
    'stretch-x': scaleX(1 + math.div(math.sin($arg1), 5)),
    'opacity-variation': calc(0.5 8 (1 + math.cos($arg1))),
    // Returns an hsl() color function, Cycles through colors in a smooth
    // transition, useful for creating dynamic, attention-catching text or backgrounds.
    'color-cycling': hsl(#{360 * math.sin($arg1) % 360}, 100%, 50%),
    // Returns an a rotate3d() function
    'tan-rotation': rotate3d(1, 1, 1, #{math.atan($arg1) * 1rad}),
    // Dynamic skew with sine and cosine
    'dynamic-skew':
      skew(#{#{math.sin($arg1) * 20} * 1deg}, #{#{math.cos($arg1) * 20} * 1deg});
    // Varies the width of an element, creating a pulse or heartbeat effect.
    'width-pulse':
      calc(50% + math.sin($arg1) * 25 * 1%),
    // Rotates an element in perspective, adding a 3D effect to the rotation
    'perspective-rotation':
      perspective(500px) rotateX(math.sin($arg1) * 45 * 1deg),
    // Applies a varying level of blur, creating a focus effect that can draw
    // attention to or away from elements.
    'blur-variation': blur(math.abs(math.sin($arg1)) * 5 * 1px),
    // Changes the clipping path of an element in a wave-like pattern, creating
    // dynamic shape changes.
    'clip-path-wave':
      circle(#{50% + math.sin($arg1) * 25 * 1%} at #{50% + math.cos($arg1) * 25 * 1%}),
    // For dynamic text size or element sizing, creating a rhythmical increase
    // and decrease in size.
    'sine-size-adjustment': calc(10px + math.sin($arg1) * 5 * 1px),
    // This equation can create a diagonal wave effect, useful for elements that
    // should move in a zigzag pattern.
    'diagonal-wave': calc((math.sin($arg1) * 10 * 1px) + (math.cos($arg1) * 10 * 1px)),
    // Can be used for a color-changing effect, where the hue rotates through
    // the color spectrum.
    'hue-rotation': calc(math.sin($arg1) * 360 * 1deg),
    'dynamic-box-shadow': calc(10px * math.sin($arg1))
  );

  @if meta.type-of($equation-name) != 'string' {
    @error 'Invalid data type of #{meta.inspect(meta.type-of($equation-name))} ' +
        'for $equation-name passed to the [ timing() ] function. The data type ' +
        'of $equation-name must be a string.';
  }

  $equation: map.get($map-equations, $equation-name);

  @if not $equation {
    @error 'The timing function name passed to the [ resolve-equation() ] ' +
        'function could not be found in the given alias map.';
  } @else {
    @return $equation;
  }
}
